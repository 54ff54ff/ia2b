/*========================================================================\
|: [Filename] aigWriter.cpp                                              :|
:| [Author]   Chiang Chun-Yi                                             |:
|: [Synopsis] Implement the AIGER writer for aig network                 :|
<------------------------------------------------------------------------*/

#include "aigWriter.h"

namespace _54ff
{

AigWriter* const aigWriter[TOTAL_PARSE_TYPE] =
	{ new AigAsciiWriter, new AigBinaryWriter };

bool
AigWriter::writeAig(const char* fileName, const AigNtk* ntk)
{
	targetNtk = ntk;
	if(!check())
		return false;
	outFile.open(fileName);
	if(!outFile.is_open())
		{ cerr << "[Error] Cannot open file \"" << fileName << "\"!" << endl;
		  return false; }
	writeHeader();
	writeInput();
	writeLatch();
	writeOutput();
	writeAnd();
	writeComment();
	outFile.close();
	idMap.reset();
	return true;
}

void
AigWriter::writeHeader()
{
	outFile << getIdentifier()
	        << " " << getMaxVarID()
	        << " " << targetNtk->getInputNum()
	        << " " << targetNtk->getLatchNum()
	        << " " << targetNtk->getOutputNum()
	        << " " << targetNtk->getAndNum() << endl;
}

void
AigWriter::writeOutput()
{
	for(size_t i = 0, O = targetNtk->getOutputNum(); i < O; ++i)
	{
		AigPo* o = targetNtk->getOutput(i);
		outFile << (idMap[o->getFanIn0ID()] * 2 + size_t(o->isFanIn0Inv()))
		        << endl;
	}
}

void
AigWriter::writeComment()
{
	time_t t = getCurTime();
	outFile << "c" << endl
	        << "generated by ia2b at " << ctime(&t);
}

bool
AigAsciiWriter::check()
{
	unsigned n = targetNtk->getMaxGateNum();
	idMap.init(n);
	AigGateID id = 0;
	for(AigGateID i = 0; i < n; ++i)
		if(AigGate* g = targetNtk->getGate(i);
		   g != 0 && g->getGateType() != AIG_PO)
			idMap[g->getGateID()] = id++;
	assert(id == getFirstOutputID());
	return true;
}

void
AigAsciiWriter::writeInput()
{
	for(size_t i = 0, I = targetNtk->getInputNum(); i < I; ++i)
		outFile << idMap[targetNtk->getInputID(i)] * 2 << endl;
}

void
AigAsciiWriter::writeLatch()
{
	for(size_t i = 0, L = targetNtk->getLatchNum(); i < L; ++i)
	{
		AigLatch* l = targetNtk->getLatch(i);
		outFile << idMap[l->getGateID()] * 2 << " "
		        << (idMap[l->getFanIn0ID()] * 2 + size_t(l->isFanIn0Inv()))
		        << endl;
	}
}

void
AigAsciiWriter::writeAnd()
{
	for(size_t i = 0, n = targetNtk->getMaxGateNum(); i < n; ++i)
		if(AigGate* a = targetNtk->getGate(i);
		   a != 0 && a->getGateType() == AIG_AND)
			outFile << idMap[a->getGateID()] * 2
			        << " "
			        << (idMap[a->getFanIn0ID()] * 2 + size_t(a->isFanIn0Inv()))
			        << " "
			        << (idMap[a->getFanIn1ID()] * 2 + size_t(a->isFanIn1Inv()))
			        << endl;
}

bool
AigBinaryWriter::check()
{
	if(!targetNtk->checkCombLoop(true, dfsList))
		return false;
	idMap.init(targetNtk->getMaxGateNum());
	AigGateID id = 0; idMap[0] = id;
	for(size_t i = 0, I = targetNtk->getInputNum(); i < I; ++i)
		idMap[targetNtk->getInputID(i)] = ++id;
	for(size_t i = 0, L = targetNtk->getLatchNum(); i < L; ++i)
		idMap[targetNtk->getLatchID(i)] = ++id;
	for(size_t i = 0, A = dfsList.size(); i < A; ++i)
		idMap[dfsList[i]->getGateID()] = ++id;
	return true;
}

void
AigBinaryWriter::writeLatch()
{
	for(size_t i = 0, L = targetNtk->getLatchNum(); i < L; ++i)
	{
		AigLatch* l = targetNtk->getLatch(i);
		outFile << (idMap[l->getFanIn0ID()] * 2 + size_t(l->isFanIn0Inv()))
		        << endl;
	}
}

void
AigBinaryWriter::writeAnd()
{
	for(unsigned i = 1 + targetNtk->getInputNum() + targetNtk->getLatchNum(),
	             M = getMaxVarID(), idx = 0; i <= M; ++i, ++idx)
	{
		AigGate* g = targetNtk->getGate(dfsList[idx]->getGateID());
		unsigned lhs  = i * 2,
		         rhs0 = idMap[g->getFanIn0ID()] * 2 + unsigned(g->isFanIn0Inv()),
		         rhs1 = idMap[g->getFanIn1ID()] * 2 + unsigned(g->isFanIn1Inv());
		if(rhs0 < rhs1) swap(rhs0, rhs1);
		decode(lhs  - rhs0);
		decode(rhs0 - rhs1);
	}
	vector<AigAnd*>().swap(dfsList);
}

//modified from the AIGER document by Armin Biere
void
AigBinaryWriter::decode(unsigned delta)
{
	constexpr unsigned PUT_VALUE_MASK = 0x7F;
	constexpr unsigned CHECK_END_MASK = ~PUT_VALUE_MASK;
	constexpr unsigned char MARK_CONT_MASK = 0x80;
	unsigned char cont = MARK_CONT_MASK;
	do
	{
		if((delta & CHECK_END_MASK) == 0)
			cont = 0;
		outFile.put((unsigned char)(delta & PUT_VALUE_MASK) | cont);
		delta >>= 7;
	} while(cont);
}

}